name: ci-cd

on:
  push:
    branches: [ main, ci-cd ]
  pull_request:

permissions:
  contents: read
  packages: write      # push to GHCR
  id-token: write      # OIDC to cloud in deploy job

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      digest: ${{ steps.build.outputs.digest }}
      image:  ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
    steps:
      - uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set tags
        id: meta
        run: |
          echo "TAG_SHA=${GITHUB_SHA}" >> $GITHUB_OUTPUT

      - name: Build & push (build once)
        id: build
        uses: docker/build-push-action@v6
        with:
          push: true
          context: .
          platforms: linux/amd64
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.TAG_SHA }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},name-canonical=true
          labels: |
            org.opencontainers.image.source=${{ github.repository }}
          metadata: true


      - name: Resolve image digest
        id: resolve
        run: |
          # dump for debug
          echo "Metadata (raw):"
          printf '%s\n' "${{ steps.build.outputs.metadata }}"
          
          # 1) אם יש output digest רשמי מהשלב build - השתמש בו
          if [ -n "${{ steps.build.outputs.digest }}" ]; then
            echo "Found digest output from build step."
            echo "digest=${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # 2) נסיון למציאת sha256:... בתוך ה-metadata (regardless of JSON)
          DIGEST=$(printf '%s\n' "${{ steps.build.outputs.metadata }}" | grep -oE 'sha256:[0-9a-f]{64}' | head -n1 || true)

          # 3) גיבוי: נסיון עם jq (אם ה-metadata במקרה כן JSON תקין)
          if [ -z "$DIGEST" ]; then
            DIGEST=$(jq -r '."containerimage.digest" // empty' <<<"${{ steps.build.outputs.metadata }}" 2>/dev/null || true)
          fi

          if [ -z "$DIGEST" ]; then
            echo "ERROR: could not extract container image digest from build outputs." >&2
            echo "Please check the build step outputs; here's the raw metadata above." >&2
            exit 1
          fi

          echo "Extracted digest: $DIGEST"
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT


  test:
    runs-on: ubuntu-latest
    needs: build
    env:
      APP_IMAGE: ${{ needs.build.outputs.image }}@${{ needs.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4

      - name: Show image under test
        run: echo "$APP_IMAGE"

      - name: Compose up (wait on health)
        run: |
          APP_IMAGE="$APP_IMAGE" docker compose -f docker-compose.yml up --build --wait --remove-orphans || {
            echo "==== docker compose ps ====";
            docker compose -f docker-compose.yml ps;
            echo "==== docker compose logs (last 200 lines) ====";
            docker compose -f docker-compose.yml logs --no-color --tail=200;
            echo "==== docker inspect exit codes ====";
            docker compose -f docker-compose.yml ps --all --quiet | xargs -r docker inspect --format '{{.Name}} {{.State.ExitCode}} {{.State.Status}}' || true;
            exit 1;
          }

      - name: Compose down
        if: always()
        run: docker compose -f docker-compose.yml down -v

  deploy:
    runs-on: ubuntu-latest
    needs: [ build, test ]
    environment: production   # protection rules / approvals
    env:
      APP_IMAGE: ${{ needs.build.outputs.image }}@${{ needs.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4

      # (Example) authenticate to cloud with OIDC (provider-specific step here)
      # - uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     role-to-assume: arn:aws:iam::<acct>:role/<role>
      #     aws-region: eu-west-1

      - name: Deploy using pinned digest
        run: |
          echo "Deploying $APP_IMAGE"
          # kubectl set image ... --image=$APP_IMAGE
          # or ECS/Knative/Nomad/etc.
