name: ci-cd

on:
  push:
    branches: [ main, ci-cd ]
  pull_request:

permissions:
  contents: read
  packages: write      # push to GHCR
  id-token: write      # OIDC to cloud in deploy job

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      digest: ${{ steps.build.outputs.digest }}
      image:  ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
    steps:
      - uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set tags
        id: meta
        run: |
          echo "TAG_SHA=${GITHUB_SHA}" >> $GITHUB_OUTPUT

      - name: Build & push (build once)
        id: build
        uses: docker/build-push-action@v6
        with:
          push: true
          context: .
          platforms: linux/amd64
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.TAG_SHA }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }},push-by-digest=true,name-canonical=true

      - name: Resolve image digest
        id: resolve
        run: |
          DIGEST=$(jq -r '.[0].digest' <<<"${{ steps.build.outputs.metadata }}")
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

  test:
    runs-on: ubuntu-latest
    needs: build
    env:
      APP_IMAGE: ${{ needs.build.outputs.image }}@${{ needs.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4

      - name: Show image under test
        run: echo "$APP_IMAGE"

      - name: Compose up (wait on health)
        run: |
          # your compose.test.yml should reference the app image by env-substitution:
          #   image: ${APP_IMAGE}
          # and include healthchecks + depends_on: condition: service_healthy
          APP_IMAGE="$APP_IMAGE" docker compose -f docker-compose.test.yml up --build --wait --remove-orphans
      - name: Compose down
        if: always()
        run: docker compose -f docker-compose.test.yml down -v

  deploy:
    runs-on: ubuntu-latest
    needs: [ build, test ]
    environment: production   # protection rules / approvals
    env:
      APP_IMAGE: ${{ needs.build.outputs.image }}@${{ needs.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4

      # (Example) authenticate to cloud with OIDC (provider-specific step here)
      # - uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     role-to-assume: arn:aws:iam::<acct>:role/<role>
      #     aws-region: eu-west-1

      - name: Deploy using pinned digest
        run: |
          echo "Deploying $APP_IMAGE"
          # kubectl set image ... --image=$APP_IMAGE
          # or ECS/Knative/Nomad/etc.
